# 架构设计方案（侧重界面交互与可配置性）

# 一、整体架构分层设计（核心原则：解耦、可扩展、数据与逻辑分离）

采用“五层架构”设计，从下到上依次为：基础设施层、数据配置层、核心逻辑层、界面交互层、应用服务层。各层职责清晰，通过接口通信，确保修改配置数据或界面布局时不影响其他模块。

|架构分层|核心职责|关键模块|扩展/配置便利性设计|
|---|---|---|---|
|基础设施层|提供底层支撑能力，保障系统稳定运行|日志模块、网络模块、资源加载模块、热更新模块|热更新模块支持配置文件、界面资源的在线更新，无需重启服务器/客户端|
|数据配置层|统一管理所有可配置数据，实现数据与逻辑分离|配置加载模块、配置校验模块、配置缓存模块|采用“配置文件+可视化编辑器”模式，支持JSON/Excel格式配置，修改后实时生效|
|核心逻辑层|实现游戏核心玩法逻辑，不直接依赖具体配置数值|境界突破模块、战斗计算模块、年龄增长模块、资源交易模块、**事件系统模块**|所有数值通过配置接口获取，修改配置不改动逻辑代码；事件规则可通过配置文件动态调整|
|界面交互层|负责界面展示与用户操作响应，与核心逻辑解耦|UI组件模块、界面路由模块、事件分发模块、**事件展示组件**|界面布局通过配置文件定义，跳转规则集中管理，新增/修改界面无需改动逻辑；事件展示样式可配置|
|应用服务层|提供玩家可直接感知的功能入口，整合各层能力|主界面服务、角色管理服务、任务社交服务、修炼服务、**事件服务**|服务模块可独立扩展，新增功能只需新增服务单元，不影响现有架构；事件服务支持动态注册新事件类型|
## 1.1 模块间通信机制（补充）

为确保各层、各模块解耦且通信高效，采用“同步接口+异步事件”双模式通信，明确通信协议与数据格式，避免直接依赖。事件系统作为核心通信枢纽，承接模块间异步交互需求。

|通信模式|适用场景|实现方式|数据格式/协议|
|---|---|---|---|
|同步接口通信|实时性要求高、需即时返回结果的场景（如核心逻辑层获取配置数据、界面层获取玩家当前修为）|基于RESTful风格的内部接口，通过接口网关统一转发与权限校验|JSON格式，字段固定（含状态码、数据体、错误信息），示例：{"code":200,"data":{"修为":100},"msg":"success"}|
|异步事件通信|实时性要求低、无需即时返回的场景（如配置热更新通知、玩家突破成功广播、日志上报、天道时间事件触发）|基于事件总线（EventBus）机制，模块注册事件监听，发送方发布事件后无需等待响应，由事件系统统一调度|事件JSON格式（含事件ID、触发模块、数据体、时间戳、事件类型），示例：{"eventId":"ConfigHotUpdate","from":"ConfigLoadModule","data":{"configType":"RealmBreakthrough"},"timestamp":1699999999999,"eventType":"系统事件"}|
关键保障：接口网关统一记录通信日志，异常时触发告警；事件总线支持事件重试机制，避免因模块临时故障导致消息丢失；事件系统内置死信队列，处理无法正常消费的异常事件。

# 1.2 事件系统架构设计（核心：可配置、可扩展、适配双时间维度）

事件系统作为核心逻辑层的枢纽模块，负责事件的定义、注册、发布、调度、消费全生命周期管理，适配“天道时间驱动事件”“红尘时间触发事件”“玩家操作触发事件”三类核心场景，实现模块解耦与业务联动，同时支持事件规则动态配置，无需改动代码即可调整事件逻辑。

## 1.2.1 事件系统分层与核心模块

事件系统内部采用“三层架构”设计，从下到上依次为：事件配置层、事件核心层、事件适配层，各层独立封装，通过标准化接口通信，确保可扩展性与可配置性。

|系统分层|核心职责|关键模块|配置/扩展设计|
|---|---|---|---|
|事件配置层|统一管理事件配置数据，实现事件规则与逻辑分离|事件配置加载模块、事件规则校验模块、事件配置缓存模块|事件规则通过JSON配置文件定义（含事件ID、触发条件、执行逻辑、奖励/惩罚、生命周期），支持热更新，修改后实时生效|
|事件核心层|负责事件全生命周期管理，调度事件流转与消费|事件注册模块、事件发布模块、事件调度模块、事件消费模块、死信队列模块|支持事件动态注册（新增事件无需修改核心代码），调度策略可配置（同步/异步消费、优先级排序）|
|事件适配层|对接外部模块，实现事件与现有业务的联动适配|天道时间事件适配模块、红尘时间事件适配模块、玩家操作事件适配模块、界面事件展示适配模块|预留外部模块适配接口，新增业务模块（如跨服战）时，仅需开发对应适配模块，无需改动事件核心逻辑|
## 1.2.2 事件分类与核心设计（适配双时间维度）

按事件触发源分为三类核心事件，各类事件独立配置触发规则，由事件系统统一调度，确保与双时间维度、核心玩法无缝衔接。

|事件类型|触发源/场景|核心配置规则（JSON示例）|生命周期与调度逻辑|
|---|---|---|---|
|天道时间事件（世界级）|由天道时间推进触发，如灵气潮汐、天材地宝出世、仙界之门开启、甲子轮回突破节点|{
"eventId": "AuraTide_10Y",
"eventName": "十年一度灵气潮汐",
"eventType": "天道时间事件",
"triggerRule": {
  "triggerTime": "仙历每10年1月", // 天道时间触发节点
  "duration": 3, // 事件持续3个月（天道时间）
  "preCondition": {"serverLevel": 1} // 服务器开启条件
},
"executeLogic": {
  "buff": {"修炼效率": 1.5}, // 全服加成
  "resourceOutput": {"灵草产出": 1.2} // 资源产出提升
},
"rewardRule": {"participateReward": "灵草x10"} // 参与奖励
}|1. 触发：天道时间模块每推进1个月，向事件系统发送“时间更新事件”，事件系统校验触发规则；2. 执行：触发后发布全服事件，同步更新全服buff、资源产出规则；3. 结束：达到持续时长后，发布事件结束通知，清理加成效果；4. 调度：优先级最高（1级），同步调度全服模块响应|
|红尘时间事件（个人级）|由玩家红尘时间消耗行为触发，如闭关突破、秘境历练、参悟功法后的事件（突破成功/失败、历练奇遇）|{
"eventId": "MeditationBreakthrough",
"eventName": "闭关突破事件",
"eventType": "红尘时间事件",
"triggerRule": {
  "triggerAction": "闭关突破", // 触发行为
  "timeConsume": 3, // 消耗3年红尘时间
  "preCondition": {"realm": "筑基初期"} // 前置境界条件
},
"executeLogic": {
  "success": {"realmUp": 1, "lifeLimitUp": 30}, // 成功：境界提升、寿元上限增加
  "fail": {"cultivationLoss": 0.15, "ageUp": 5} // 失败：修为损失15%、年龄+5岁
},
"rewardRule": {"successReward": "筑基丹x1"}
}|1. 触发：玩家执行红尘时间消耗行为（如点击闭关），应用服务层向事件系统发布“红尘时间事件”；2. 执行：事件系统校验条件，执行突破逻辑，计算结果；3. 结束：返回突破结果，同步更新玩家数据（境界、年龄、修为）；4. 调度：优先级中等（2级），异步调度，不阻塞玩家操作|
|玩家操作事件（交互级）|由玩家即时操作触发，如使用道具、交易、组队、触发机缘（采集天材地宝）|{
"eventId": "TreasureCollect",
"eventName": "天材地宝采集事件",
"eventType": "玩家操作事件",
"triggerRule": {
  "triggerAction": "采集", // 触发操作
  "target": "千年灵草", // 触发目标
  "preCondition": {"eventTime": "仙历300年3月-9月"} // 天道时间窗口期
},
"executeLogic": {
  "success": {"getItem": "千年灵草x1", "luckUp": 5}, // 成功：获得物品、气运+5
  "fail": {"itemLoss": "普通灵草x2"} // 失败：消耗材料
},
"rewardRule": {"criticalSuccessReward": "寿元果x1"} // 暴击奖励
}|1. 触发：玩家执行操作（如采集），界面交互层向事件系统发布“操作事件”；2. 执行：事件系统校验天道时间窗口期、玩家条件，执行采集逻辑；3. 结束：返回采集结果，更新玩家背包、属性；4. 调度：优先级最低（3级），同步执行，即时反馈结果|
## 1.2.3 事件全生命周期管理流程

事件系统通过“注册-触发-调度-消费-结束-归档”六步流程，实现事件全生命周期管控，确保流程规范、可追溯、可扩展。

1. **事件注册**：模块启动时，通过事件注册接口向事件系统注册所需监听的事件（如界面层注册“突破成功事件”监听）；新增事件类型时，可通过配置文件注册，无需修改代码，事件系统自动加载配置并完成注册。

2. **事件触发**：触发源（天道时间模块、玩家操作、红尘时间行为）满足事件配置的触发规则后，向事件系统发布事件，携带事件ID、触发参数（如时间、玩家ID、行为类型）。

3. **事件调度**：事件调度模块接收事件后，按事件优先级（1级最高）排序，选择调度策略（同步/异步），将事件分发至对应的消费模块；若消费模块临时故障，将事件放入死信队列，重试3次后归档。

4. **事件消费**：消费模块接收事件后，执行对应业务逻辑（如界面层接收“突破成功事件”后，展示突破动画与奖励）；消费完成后，向事件系统返回消费结果（成功/失败）。

5. **事件结束**：事件达到结束条件（如持续时长到期、操作完成），事件系统发布事件结束通知，清理事件相关资源（如全服buff、临时数据）。

6. **事件归档**：事件结束后，将事件日志（触发时间、执行结果、参与玩家、奖励发放）归档至数据库，支持后续查询与审计。

## 1.2.4 事件系统与现有模块联动机制

事件系统作为模块间通信枢纽，通过适配层与现有核心模块联动，确保业务流程顺畅，不改动现有模块核心逻辑。

|联动模块|联动场景|联动方式|
|---|---|---|
|天道时间模块|天道时间推进触发世界级事件|天道时间模块每推进1个月，发布“时间更新事件”；事件系统通过适配层接收事件，校验所有天道时间事件的触发规则，满足条件则触发对应事件|
|红尘时间模块|红尘时间消耗行为触发个人事件|玩家执行红尘时间行为（如闭关），红尘时间模块发布“时间消耗事件”；事件系统接收后，执行对应事件逻辑（突破计算），返回结果并同步更新玩家年龄、修为|
|境界突破模块|突破成功/失败事件的发布与消费|境界突破模块完成突破计算后，向事件系统发布“突破结果事件”；事件系统将事件分发给界面层（展示结果）、资源模块（扣除/发放材料）、日志模块（记录日志）|
|界面交互层|事件展示与玩家操作响应|界面层通过事件展示组件监听事件，接收事件后展示对应UI（如事件弹窗、动画、奖励提示）；玩家通过界面操作触发事件，界面层向事件系统发布“操作事件”|
## 1.2.5 事件配置文件设计（标准化格式）

事件配置文件按事件类型分类存储（如《HeavenlyTimeEventConfig.json》《RedDustTimeEventConfig.json》），采用标准化JSON格式，支持可视化编辑工具修改，确保非开发人员可操作。

### 核心配置字段说明

- **基础信息**：eventId（唯一标识）、eventName（事件名称）、eventType（事件类型）、description（事件描述）—— 用于事件识别与展示。

- **触发规则**：triggerRule（触发条件，含时间、行为、前置条件）、triggerSource（触发源）—— 定义事件触发的核心条件，支持多条件组合。

- **执行逻辑**：executeLogic（事件执行的业务逻辑，含成功/失败处理、属性变更、buff叠加）—— 核心业务规则，可配置多分支逻辑。

- **奖励/惩罚**：rewardRule（奖励规则，含参与奖、成功奖、暴击奖）、punishRule（惩罚规则，含失败惩罚、超时惩罚）—— 支持动态配置奖励内容与发放条件。

- **生命周期**：duration（持续时长）、timeout（超时时间）、archive（是否归档）—— 控制事件流转与后续处理。

## 1.2.6 容错与监控设计（保障系统稳定）

事件系统内置多层容错机制与监控指标，确保事件流转稳定，异常可追溯、可告警。

### 1. 容错机制

- **事件消费容错**：消费模块故障时，事件放入死信队列，重试3次（每次间隔5秒），重试失败则归档并触发告警；支持手动重试消费死信事件。

- **配置容错**：事件配置缺失/格式错误时，加载默认配置（如默认奖励、基础触发规则），同时上报日志与告警，不影响事件系统整体运行。

- **联动容错**：联动模块（如天道时间模块）故障时，事件系统暂存事件，待模块恢复后自动触发，确保事件不丢失。

### 2. 核心监控指标

- 事件触发成功率：要求≥99.9%，低于阈值则告警（可能是触发规则配置错误）。

- 事件消费成功率：要求≥99.5%，低于阈值则告警（可能是消费模块故障）。

- 事件调度耗时：单事件调度耗时≤100ms，超时则告警（可能是事件优先级配置不合理）。

- 死信队列堆积量：堆积量≥10则告警（可能是消费模块持续故障）。

- 事件配置热更新成功率：要求≥99.9%，低于阈值则告警（可能是新配置格式错误）。

## 1.2.7 扩展性设计（支持后续功能新增）

事件系统通过“配置化+接口化+适配层”设计，支持后续新增事件类型与业务模块，无需改动核心逻辑。

- **新增事件类型**：只需新增对应事件配置文件，定义触发规则、执行逻辑等，事件系统自动加载配置并完成注册，无需修改核心代码。

- **新增联动模块**：通过事件适配层预留的接口，开发对应模块的适配单元，注册监听所需事件即可实现联动，不影响现有模块。

- **新增调度策略**：支持在配置文件中定义自定义调度策略（如按玩家等级排序消费），事件系统自动适配，无需修改调度核心逻辑。

# 二、界面交互架构设计（解决界面布局与点击跳转问题）

## 2.1 核心设计思路：组件化+路由化

将界面拆分为可复用组件，通过统一路由管理跳转逻辑，实现“布局可配置、跳转可管控、扩展可新增”的目标。

## 2.2 界面组件化设计

拆分通用组件与业务组件，组件独立封装，可跨界面复用，修改组件不影响其他模块。

|组件类型|包含组件|设计说明|
|---|---|---|
|通用组件|顶部信息栏、底部功能栏、弹窗组件、列表组件、进度条组件、**事件提示组件**|通用组件通过配置文件定义样式和展示内容，如顶部信息栏可配置显示“角色名称、境界、气血”等字段，支持动态增减字段；事件提示组件可配置事件弹窗样式、展示时长，适配各类事件提示场景|
|业务组件|角色属性组件、修炼进度组件、任务列表组件、社交关系组件、**事件列表组件**|业务组件依赖核心逻辑层接口获取数据，仅负责展示与交互，如角色属性组件通过“获取角色数据接口”获取修为、寿命等信息，无需关心数据计算逻辑；事件列表组件通过监听事件系统，展示当前可参与事件、已完成事件，支持点击查看详情|
## 

# 三、可配置系统架构设计（核心解决配置数据易修改问题）

## 3.1 核心设计思路：配置中心化+接口标准化

将所有可配置数据（初始数据、境界数据、材料数据、**事件配置数据**等）集中存储在配置文件中，核心逻辑层通过标准化接口获取数据，实现“修改配置文件即可调整游戏数值，无需改动代码”。

## 3.2 配置数据分类与存储

按功能模块分类存储配置文件，每个分类对应独立的JSON文件，结构清晰，方便查找和修改。新增事件配置分类，存储各类事件的规则配置文件。

## 3.3 配置加载与生效机制

通过“配置加载模块”实现配置文件的加载、缓存、校验与热更新，确保配置修改高效且安全。事件配置文件遵循相同的加载与生效机制，支持热更新。

1. 启动加载：游戏启动时，配置加载模块自动加载所有分类的配置文件（含事件配置），解析为内存中的数据对象，同时进行格式校验（如检查数值是否为正数、事件ID是否唯一），校验失败则输出日志并使用默认配置

2. 缓存管理：加载后的配置数据存储在缓存中，核心逻辑层（含事件系统）通过接口获取数据时，直接从缓存读取，提升性能

3. 热更新生效：修改配置文件（含事件配置）后，通过“热更新接口”触发配置重新加载，无需重启服务器/客户端，新配置在10秒内全局生效；支持配置回滚，若修改后出现问题，可快速恢复至历史版本

## 3.4 标准化配置接口设计

核心逻辑层通过标准化接口获取配置数据，接口参数统一，返回格式固定，避免直接操作配置文件。新增事件配置接口，支持事件系统获取各类事件配置数据。

说明：新增配置数据时，只需新增对应的配置文件和接口；修改配置数据时，接口无需改动，仅需修改配置文件。

## 3.5 配置加载模块容错与监控设计（补充）

为避免配置加载异常影响游戏运行，新增容错机制与监控指标，保障模块稳定。

### 3.5.1 多层容错机制

1. 文件级容错：配置文件缺失/损坏时，自动从“备份配置目录”加载最近一次备份文件；备份文件也失效则加载默认配置（Default_XXX.json），同时触发邮件告警。

2. 字段级容错：配置文件字段缺失/格式错误时，跳过错误字段使用默认值（如修为上限缺失则默认1000，事件持续时长缺失则默认1），并在日志中详细标注错误字段位置，便于排查。

3. 网络级容错：若配置文件存储在云服务，网络中断时自动切换至本地缓存的配置文件，网络恢复后同步最新配置。

### 3.5.2 核心监控指标与告警

配置加载模块内置监控探针，实时采集以下指标，通过监控平台展示，异常时触发告警（邮件+钉钉）：

- 配置加载成功率：要求≥99.9%，低于阈值则告警（可能是文件损坏或网络问题）。

- 热更新成功率：要求≥99.5%，低于阈值则告警（可能是新配置格式错误）。

- 加载耗时：单类配置加载耗时≤500ms，总加载耗时≤3s（启动时），超时则告警（可能是配置文件过大）。

- 配置变更频率：记录每类配置的修改次数，异常高频修改（如1小时内≥10次）触发告警（可能是误操作）。

## 3.6 配置编辑工具（可视化辅助）

核心逻辑层通过标准化接口获取配置数据，接口参数统一，返回格式固定，避免直接操作配置文件。

说明：新增配置数据时，只需新增对应的配置文件和接口；修改配置数据时，接口无需改动，仅需修改配置文件。

## 3.5 配置编辑工具（可视化辅助）

为非开发人员设计可视化配置编辑工具，支持通过界面直接修改配置数据，自动校验格式并生成标准配置文件，降低修改门槛。新增事件配置编辑功能，支持可视化配置事件规则。

工具核心功能：

- 配置分类导航：按模块展示所有配置文件（含事件配置），点击即可进入编辑界面

- 可视化编辑：通过表单、下拉框、列表等组件编辑数据，如选择“事件ID”时下拉展示所有事件，选择“触发时间”时适配天道时间格式，无需手动输入

- 数据校验：实时校验输入数据的合理性（如事件持续时长不能为负数、奖励数量需为整数），错误数据标红提示

- 版本管理：记录配置修改历史，支持一键回滚至任意历史版本

- 一键生效：编辑完成后点击“生效”按钮，自动同步配置文件并触发热更新，无需手动上传文件

## 3.6 数据存储方案细分（JSON vs 数据库）

核心设计原则：**静态配置数据用JSON存储，动态业务数据用数据库存储**，通过配置加载模块与数据访问层联动，确保数据一致性与访问效率，同时兼顾配置灵活性与数据持久化需求。

### 3.6.1 存储介质选型标准

- JSON存储适用场景：数据结构稳定、变更频率低（或需支持热更新）、无复杂查询需求的静态配置数据，核心优势是编辑便捷、支持热更新、适配配置加载模块的现有设计。

- 数据库存储适用场景：数据动态变化、需持久化存储、支持复杂查询/事务/关联查询的业务数据，核心优势是支持数据一致性校验、高并发访问、复杂条件筛选。

### 3.6.2 具体数据分类与存储介质对应表

|数据类型|存储介质|包含数据|设计说明|
|---|---|---|---|
|核心静态配置|JSON文件|角色初始配置、境界突破配置、功法法宝配置、年龄增长配置、资源产出配置、界面布局配置、路由跳转配置、**事件配置数据**|对应原有`RoleInitConfig.json`等文件，新增事件配置文件（如《HeavenlyTimeEventConfig.json》），统一放在配置目录，由配置加载模块加载校验，支持热更新|
|玩家动态数据|关系型数据库（MySQL）+ 缓存（Redis）|玩家基础信息（角色ID、名称、当前境界、当前年龄、当前修为）、背包物品数据、已学功法数据、任务进度数据、社交关系数据、**玩家事件参与记录**|MySQL存储完整数据，Redis缓存高频访问数据（如当前境界、修为），减轻数据库压力；玩家数据修改通过事务保证一致性；玩家事件参与记录用于追溯玩家参与的事件及奖励获取情况|
|系统日志数据|关系型数据库（MySQL）|配置修改日志、玩家操作日志、热更新日志、异常报错日志、**事件生命周期日志**|复用MySQL存储，通过合理表结构设计（加时间索引）支撑时间范围查询；无需额外部署时序数据库，简化部署运维，适配单人开发和低配服务器资源；事件生命周期日志记录事件触发、执行、结束全流程，便于问题排查|
|临时交互数据|Redis缓存|玩家在线状态、秘境匹配队列、交易挂单临时数据、活动临时排名、**当前生效事件临时数据**|数据时效性短，用Redis存储可提升访问速度，设置过期时间自动清理，减少存储冗余；当前生效事件临时数据（如灵气潮汐buff）用于快速查询当前激活的事件效果|
### 3.6.3 数据同步与校验机制

JSON配置与数据库数据存在关联时（如突破材料配置与玩家背包材料数据、事件配置与玩家事件参与记录），需通过以下机制保证一致性：

1. 配置加载阶段：配置加载模块加载JSON配置（如突破材料、事件规则）后，会联动数据访问层校验数据库中对应基础数据（如材料基础信息表、事件基础信息表）是否存在，缺失则触发告警并使用默认数据。

2. 业务运行阶段：玩家触发突破、参与事件等操作时，核心逻辑层先从配置加载模块获取最新JSON配置（如突破所需材料、事件奖励规则），再从数据库查询玩家当前数据（如背包材料数量、事件参与资格），两者比对通过后才执行后续操作。

3. 热更新同步：JSON配置热更新后，配置加载模块会向核心逻辑层（含事件系统）发送事件，核心逻辑层同步更新依赖该配置的业务逻辑（如事件规则变更），无需修改玩家数据库数据。

### 3.6.4 数据库选型补充建议

- 核心业务数据（玩家数据）：选用MySQL 8.0，支持事务、外键关联，成熟稳定，适配游戏业务的复杂查询需求（如查询玩家已完成的所有任务、参与的所有事件）。

- 缓存数据：选用Redis 6.x，支持多种数据结构（Hash、List、Sorted Set），可适配玩家背包、排名、当前生效事件等多种场景，同时支持发布订阅机制，便于实现数据实时同步。

日志数据：复用MySQL存储，无需额外部署数据库，通过表结构优化（时间索引、JSON字段）适配日志的时序存储与查询需求，降低运维成本

## 3.7 架构安全设计（补充）

针对配置数据安全与玩家数据安全，新增多层安全防护机制，避免数据泄露或恶意篡改。

### 3.7.1 配置文件安全

- 文件加密：核心配置文件（如境界突破、功法属性、**事件规则配置**）采用AES-256加密存储，配置加载模块加载时自动解密，避免明文泄露核心数值与事件规则。

- 修改权限控制：配置编辑工具关联角色权限，仅“配置管理员”可修改核心配置（含事件配置），修改前需输入二次验证密码，修改后留存操作日志（含操作人员、时间、修改前后内容）。

- 防篡改校验：配置文件生成时附加MD5校验码，加载时校验文件MD5值，若不一致则判定为被篡改，拒绝加载并触发告警。

### 3.7.2 玩家数据安全

- 数据传输加密：玩家数据（如修为、背包物品、事件参与记录）在客户端与服务器间传输时，采用HTTPS协议加密，避免中途被截取篡改。

- 数据库加密：MySQL中玩家核心数据字段（如角色ID、账号信息）采用加密存储，数据访问层查询时自动解密，防止数据库被入侵后数据泄露。

- 操作日志审计：记录玩家所有敏感操作（如突破境界、交易道具、参与事件），日志不可篡改，便于后续追溯异常操作（如恶意刷事件奖励）。

## 3.8 核心流程时序图（补充）

通过时序图清晰展示关键流程的模块交互逻辑，便于开发落地：

### 3.8.1 配置启动加载时序图

```Plain Text


sequenceDiagram
    系统启动模块->>配置加载模块: 发送启动加载指令
    配置加载模块->>环境配置模块: 获取当前环境（开发/测试/正式）
    环境配置模块-->>配置加载模块: 返回环境配置（配置文件路径）
    配置加载模块->>配置文件存储: 批量读取核心配置文件（含事件配置）
    配置文件存储-->>配置加载模块: 返回配置文件流
    配置加载模块->>配置校验模块: 执行格式+联动校验
    配置校验模块-->>配置加载模块: 返回校验结果（通过/失败+错误信息）
    alt 校验通过
        配置加载模块->>配置缓存模块: 写入内存缓存
        配置缓存模块-->>配置加载模块: 缓存成功确认
        配置加载模块->>核心逻辑层: 发送配置加载完成事件
        核心逻辑层->>事件系统模块: 触发事件配置初始化
    else 校验失败
        配置加载模块->>备份配置目录: 加载备份/默认配置
        备份配置目录-->>配置加载模块: 返回备份配置
        配置加载模块->>日志模块: 上报校验失败日志+告警
        配置加载模块->>配置缓存模块: 写入备份配置至缓存
        配置加载模块->>核心逻辑层: 发送配置加载完成（降级）事件
        核心逻辑层->>事件系统模块: 触发事件配置初始化（降级）
    end
    
```

### 3.8.2 玩家境界突破时序图（关联配置与数据库）

```Plain Text


sequenceDiagram
    玩家客户端->>界面交互层: 点击“突破”按钮
    界面交互层->>UI路由模块: 发送跳转请求（功能ID:Breakthrough）
    UI路由模块->>核心逻辑层: 校验突破权限（修为/材料）
    核心逻辑层->>配置加载模块: 调用GetRealmBreakthroughData接口（当前境界ID）
    配置加载模块-->>核心逻辑层: 返回突破所需配置（修为/材料/寿命上限）
    核心逻辑层->>数据访问层: 查询玩家当前数据（修为/背包材料/年龄）
    数据访问层->>MySQL数据库: 读取玩家数据
    MySQL数据库-->>数据访问层: 返回玩家数据
    数据访问层-->>核心逻辑层: 返回玩家数据
    核心逻辑层->>核心逻辑层: 比对配置要求与玩家数据
    alt 满足突破条件
        核心逻辑层->>数据访问层: 执行突破数据更新（境界提升/材料扣除）
        数据访问层->>MySQL数据库: 事务更新玩家数据
        MySQL数据库-->>数据访问层: 更新成功
        数据访问层-->>核心逻辑层: 数据更新确认
        核心逻辑层->>事件系统模块: 发布突破成功事件（eventId:RealmBreakSuccess）
        事件系统模块->>事件调度模块: 调度事件分发
        事件调度模块->>界面交互层: 推送突破成功事件
        事件调度模块->>资源模块: 推送突破奖励发放事件
        事件调度模块->>日志模块: 推送事件归档日志
        界面交互层->>玩家客户端: 展示突破成功动画与奖励
    else 不满足条件
        核心逻辑层->>界面交互层: 返回不满足条件原因（如材料不足）
        界面交互层->>玩家客户端: 展示错误提示
    end
    
```

### 3.8.3 天道时间事件触发时序图（新增）

```Plain Text


sequenceDiagram
    天道时间模块->>事件系统模块: 发布时间更新事件（当前仙历：300年1月）
    事件系统模块->>事件配置加载模块: 调用GetHeavenlyTimeEvent接口（当前仙历）
    事件配置加载模块-->>事件系统模块: 返回匹配的事件配置（灵气潮汐事件）
    事件系统模块->>事件校验模块: 校验事件触发条件（服务器等级、持续时长）
    事件校验模块-->>事件系统模块: 返回校验通过结果
    事件系统模块->>事件调度模块: 发布灵气潮汐事件（优先级1级，同步调度）
    事件调度模块->>修炼模块: 推送灵气潮汐事件（修炼效率×1.5）
    事件调度模块->>资源产出模块: 推送灵气潮汐事件（灵草产出×1.2）
    事件调度模块->>界面交互层: 推送事件通知（全服弹窗）
    修炼模块-->>事件系统模块: 返回事件响应结果（加成已生效）
    资源产出模块-->>事件系统模块: 返回事件响应结果（产出规则已更新）
    界面交互层-->>事件系统模块: 返回事件响应结果（通知已展示）
    事件系统模块->>Redis缓存: 存储当前生效事件数据（灵气潮汐，持续3个月）
    事件系统模块->>日志模块: 记录事件触发日志（事件ID、触发时间、影响范围）
    
```

### 3.6.5 MySQL存储日志数据的适配方案（补充）

针对单人开发+Win2核4G服务器场景，优化日志表结构与配置，确保存储高效、查询流畅：

#### 1. 日志表结构优化（适配MySQL存储）

采用“主表+分区表”设计，按时间分区减少单表数据量，提升查询效率，同时简化索引设计适配低配服务器：

```Plain Text

-- 事件生命周期日志主表（存储基础信息）
CREATE TABLE event_lifecycle_log (
    id BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '日志ID',
    event_id VARCHAR(50) NOT NULL COMMENT '事件ID',
    event_name VARCHAR(100) NOT NULL COMMENT '事件名称',
    event_type VARCHAR(30) NOT NULL COMMENT '事件类型（天道/红尘/玩家操作）',
    trigger_time DATETIME NOT NULL COMMENT '触发时间（现实时间）',
    server_id INT NOT NULL COMMENT '服务器ID',
    status TINYINT NOT NULL COMMENT '事件状态（0-触发中，1-已结束，2-异常终止）',
    extend_info JSON COMMENT '扩展信息（存储事件buff、奖励等动态数据）',
    INDEX idx_event_id (event_id),
    INDEX idx_trigger_time (trigger_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='事件生命周期日志主表';

-- 按年分区（自动创建分区）
ALTER TABLE event_lifecycle_log 
PARTITION BY RANGE (TO_DAYS(trigger_time)) (
    PARTITION p2025 VALUES LESS THAN (TO_DAYS('2026-01-01')),
    PARTITION p2026 VALUES LESS THAN (TO_DAYS('2027-01-01')),
    PARTITION p2027 VALUES LESS THAN MAXVALUE
);
```

说明：分区表按触发时间年度分区，查询指定时间范围的事件日志时，仅扫描对应分区，避免全表扫描；extend_info用JSON字段存储动态数据，减少表字段冗余，适配各类事件的日志需求。

#### 2. 日志写入与查询优化

（1）写入优化：采用“批量写入+异步提交”机制，事件结束后批量归档日志数据，减少MySQL写入频次，适配2核4G服务器性能；日志写入失败时，暂存至Redis队列，重试3次后仍失败则写入本地文件，避免日志丢失。

（2）查询优化：高频查询的日志数据（如近7天事件日志）缓存至Redis，查询时优先从缓存获取；支持按事件ID、时间范围、事件类型组合查询，通过联合索引提升查询速度，确保单次查询耗时≤500ms。

# 四、新老玩家数据兼容方案（新增字段/配置适配）

核心设计原则：**配置化定义默认值+启动时批量同步+运行时动态补全**，确保新增字段（如人物属性、事件相关字段）对新老玩家均兼容，数据写入无异常，同时适配现有数据存储与校验机制。

## 4.1 新增字段兼容核心流程

新增玩家字段（如“气运值”“已参与事件次数”）时，按以下流程执行，确保新老玩家数据一致：

1. **配置化定义默认值**：在对应JSON配置文件中新增字段默认值（如角色初始配置文件《RoleInitConfig.json》），避免硬编码，支持后续动态调整。示例：

```Plain Text

{
  "roleInitData": {
    "baseAttr": {
      "luck": 100, // 新增“气运值”字段，默认值100
      "participatedEventCount": 0 // 新增“已参与事件次数”，默认值0
    },
    "extendAttr": {}
  },
  "newFieldSyncRule": { // 新增字段同步规则配置
    "fieldName": "luck",
    "defaultValue": 100,
    "syncScope": "allOldPlayers", // 同步范围：所有老玩家
    "syncTime": "serverStart" // 同步时机：服务器启动时
  }
}
```

1. **数据库表结构升级**：修改MySQL玩家数据表（如player_base_info），新增对应字段并设置默认值，确保新玩家注册时自动写入默认值；同时更新Redis缓存模板，新增字段缓存逻辑。示例SQL：

```Plain Text

-- 新增玩家“气运值”字段，默认值100
ALTER TABLE player_base_info 
ADD COLUMN luck INT NOT NULL DEFAULT 100 COMMENT '气运值，默认100' AFTER age;
-- 新增“已参与事件次数”字段，默认值0
ALTER TABLE player_base_info 
ADD COLUMN participated_event_count INT NOT NULL DEFAULT 0 COMMENT '已参与事件次数，默认0' AFTER luck;
```

1. **老玩家数据批量同步**：通过“配置加载模块”联动“数据同步服务”，在服务器启动时执行老玩家数据补全，同步规则读取JSON配置，无需手动编写同步脚本，适配单人开发效率。

2. **运行时动态补全（容错）**：针对未同步成功的老玩家（如服务器启动时未加载完成），在玩家首次登录/触发相关业务（如参与事件）时，动态补全新增字段默认值，确保业务正常执行。

3. **数据校验与监控**：同步完成后，自动校验老玩家新增字段数据一致性，异常数据（如字段缺失、值为空）触发告警并自动修复；同时监控新玩家字段写入情况，确保默认值正常写入。

## 4.2 老玩家数据同步机制（核心适配）

采用“启动时批量同步+运行时动态补全”双机制，确保所有老玩家均能正确同步新增字段，同时避免同步操作占用过多服务器资源（适配2核4G服务器）。

### 4.2.1 启动时批量同步（主力同步方式）

服务器启动时，配置加载模块加载新增字段同步规则，触发数据同步服务执行批量同步，流程如下：

```Plain Text

sequenceDiagram
    系统启动模块->>配置加载模块: 发送启动完成指令
    配置加载模块->>配置校验模块: 校验新增字段配置（默认值、同步规则）
    配置校验模块-->>配置加载模块: 返回校验通过结果
    配置加载模块->>数据同步服务: 发送老玩家字段同步指令（携带同步规则）
    数据同步服务->>MySQL数据库: 查询所有未同步新增字段的老玩家（字段缺失/值异常）
    MySQL数据库-->>数据同步服务: 返回老玩家列表（按批次，每批100条）
    数据同步服务->>MySQL数据库: 批量更新新增字段为默认值
    MySQL数据库-->>数据同步服务: 返回更新结果
    数据同步服务->>Redis缓存: 同步更新老玩家缓存数据
    Redis缓存-->>数据同步服务: 缓存更新成功
    数据同步服务->>日志模块: 记录同步日志（成功数量、失败数量）
    数据同步服务->>监控模块: 上报同步完成指标（成功率要求≥99.9%）
    监控模块->>配置加载模块: 同步状态反馈（成功/失败）
    alt 同步失败
        数据同步服务->>备份服务: 记录失败玩家ID，存入重试队列
        备份服务-->>数据同步服务: 队列存储确认
        数据同步服务->>监控模块: 触发告警（邮件+钉钉）
    end
```

优化点：批量同步按“每批100条”拆分，避免单次更新数据量过大导致服务器卡顿；同步操作在服务器启动后后台异步执行，不影响玩家登录流程。

### 4.2.2 运行时动态补全（容错机制）

针对批量同步失败的老玩家（如网络波动、数据库临时故障），在玩家触发以下场景时，自动补全新增字段：

- 玩家首次登录：登录服务校验玩家数据时，若发现新增字段缺失/异常，自动写入默认值并同步至数据库与缓存。

- 触发关联业务：玩家执行与新增字段相关的操作（如参与事件、使用影响气运的道具）时，核心逻辑层先校验字段完整性，缺失则补全默认值后再执行业务逻辑。

示例逻辑（伪代码）：

```Plain Text

// 参与事件时校验并补全“已参与事件次数”字段
function participateEvent(playerId) {
    // 1. 查询玩家数据
    let playerData = redis.get(`player:${playerId}`);
    // 2. 校验新增字段完整性
    if (!playerData.participatedEventCount) {
        // 补全默认值0
        playerData.participatedEventCount = 0;
        // 同步至数据库与缓存
        db.update(`UPDATE player_base_info SET participated_event_count=0 WHERE player_id=${playerId}`);
        redis.set(`player:${playerId}`, playerData);
        log.info(`玩家${playerId}补全参与事件次数字段，默认值0`);
    }
    // 3. 执行参与事件逻辑
    playerData.participatedEventCount += 1;
    // ...后续业务逻辑
}
```

### 4.2.3 同步规则配置化设计（可扩展）

支持通过JSON配置文件定义不同新增字段的同步规则，适配多样化场景（如部分字段仅同步特定老玩家、按玩家境界设置不同默认值），无需修改代码：

```Plain Text

{
  "newFieldSyncRules": [
    {
      "fieldName": "luck", // 字段名
      "defaultValue": 100, // 默认值
      "syncScope": "allOldPlayers", // 同步范围：所有老玩家
      "syncTime": "serverStart", // 同步时机：服务器启动
      "extendRule": {} // 扩展规则（无）
    },
    {
      "fieldName": "eventBonus", // 新增“事件奖励加成”字段
      "defaultValue": 1.0, // 默认加成1.0倍
      "syncScope": "realm>=金丹", // 同步范围：金丹及以上境界老玩家
      "syncTime": "runtime", // 同步时机：运行时动态同步
      "extendRule": {
        "realmCondition": { // 按境界设置不同默认值
          "金丹": 1.1,
          "元婴": 1.2,
          "化神": 1.3
        }
      }
    }
  ]
}
```

## 4.3 新玩家数据写入保障

新玩家注册时，通过“配置化初始化+数据库默认值+校验”三重保障，确保新增字段正常写入：

1. **配置化初始化**：新玩家注册时，核心逻辑层从《RoleInitConfig.json》读取新增字段默认值，构建完整的玩家初始数据对象。

2. **数据库默认值兜底**：MySQL数据表新增字段时设置默认值，若配置初始化失败，数据库自动写入默认值，避免字段缺失。

3. **注册数据校验**：注册完成后，校验新增字段是否存在且值合法（如默认值100是否正确写入），异常则触发重试机制，确保数据写入成功。

## 4.4 容错与监控设计（保障数据一致性）

### 4.4.1 多层容错机制

- **同步失败重试**：批量同步失败的玩家ID存入重试队列，服务器启动后每5分钟重试一次，重试3次仍失败则记录至本地文件，支持手动触发同步。

- **数据异常修复**：监控模块实时检测玩家新增字段数据，发现异常（如值为空、超出合理范围）时，自动修复为默认值并上报日志。

- **配置容错**：若新增字段配置缺失，自动使用数据库默认值，同时触发告警，避免因配置错误导致数据写入异常。

### 4.4.2 核心监控指标

监控模块新增以下指标，实时监控新老玩家数据写入/同步情况，异常时触发告警：

- 老玩家字段同步成功率：要求≥99.9%，低于阈值则告警（可能是同步规则配置错误、数据库故障）。

- 新玩家字段写入成功率：要求100%，低于阈值则告警（可能是配置初始化失败、数据库表结构未升级）。

- 数据异常率：新增字段异常数据（缺失/值非法）占比≤0.1%，超出则告警（可能是容错机制失效）。

- 同步耗时：批量同步总耗时≤5分钟（适配2核4G服务器），超时则告警（可能是老玩家数量过多，需拆分同步批次）。

## 4.5 与现有架构的联动适配

本方案完全嵌入现有架构，无需改动核心模块，联动关系如下：

- 与可配置系统联动：新增字段默认值、同步规则通过JSON配置文件定义，复用现有配置加载、校验、热更新机制。

- 与数据存储模块联动：复用MySQL+Redis存储方案，新增字段的写入、缓存同步逻辑嵌入现有数据访问层，无需重构存储架构。

- 与事件系统联动：新增事件相关字段（如已参与事件次数）的同步，由事件系统触发动态补全，确保玩家参与事件时数据正常。

- 与监控模块联动：新增监控指标嵌入现有监控体系，复用告警机制（邮件+钉钉），无需新增监控组件。

## 4.6 实操建议（适配单人开发）

1. 字段新增流程简化：建议先在JSON配置中定义默认值与同步规则，再执行数据库表结构升级，最后启动服务器触发批量同步，避免流程混乱。

2. 小批量测试验证：新增字段后，先在测试服同步少量老玩家数据，验证同步机制与业务兼容性，再部署至正式服。

3. 备份机制：同步前自动备份老玩家数据（MySQL全量备份+Redis快照），若同步出错可快速回滚，避免数据丢失。

#### 1. 日志表
> （注：文档部分内容可能由 AI 生成）